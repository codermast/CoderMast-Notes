import{_ as l}from"./2023-06-20-13-53-06-ClJW8S_1.js";import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,o as t,a as s,b as i,e}from"./app-e7gUmT_h.js";const h="/assets/2023-06-19-16-10-46-Bf8_8OJh.png",p="/assets/2023-06-19-16-23-07-cK6TU_OC.png",k="/assets/2023-06-19-16-35-31-BoPXDD3O.png",d="/assets/2023-06-19-17-35-53-srNp6awl.png",r="/assets/2023-06-19-17-58-33-CptMz599.png",c="/assets/2023-06-19-23-08-33-zKa6wzSJ.png",o="/assets/2023-06-20-11-17-41-B7EQcFBP.png",g="/assets/2023-06-20-13-59-29-ice2lJAX.png",A="/assets/2023-06-20-14-02-25-wyHxaUFt.png",y="/assets/2023-06-20-14-08-37-BiHebdI8.png",f={},u=s('<h1 id="redis原理-io详解" tabindex="-1"><a class="header-anchor" href="#redis原理-io详解"><span>Redis原理 - IO详解</span></a></h1><h2 id="用户空间与内核空间" tabindex="-1"><a class="header-anchor" href="#用户空间与内核空间"><span>用户空间与内核空间</span></a></h2><p>任何Linux 系统的发行版，其系统内核都是 Linux 。我们的应用都需要通过 Linux 内核与硬件交互。</p><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>为了避免用户应用导致冲突甚至内核崩溃，用户应用与内核是分离的：</p><ul><li>内存的寻址空间划分为两部分：内核空间、用户空间</li></ul>',6),m=i("blockquote",null,[i("p",null,[e("32 位的操作系统，寻址地址就为 0 ~ "),i("span",{class:"katex"},[i("span",{class:"katex-mathml"},[i("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[i("semantics",null,[i("mrow",null,[i("msup",null,[i("mn",null,"2"),i("mn",null,"32")])]),i("annotation",{encoding:"application/x-tex"},"2 ^ {32}")])])]),i("span",{class:"katex-html","aria-hidden":"true"},[i("span",{class:"base"},[i("span",{class:"strut",style:{height:"0.8141em"}}),i("span",{class:"mord"},[i("span",{class:"mord"},"2"),i("span",{class:"msupsub"},[i("span",{class:"vlist-t"},[i("span",{class:"vlist-r"},[i("span",{class:"vlist",style:{height:"0.8141em"}},[i("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[i("span",{class:"pstrut",style:{height:"2.7em"}}),i("span",{class:"sizing reset-size6 size3 mtight"},[i("span",{class:"mord mtight"},[i("span",{class:"mord mtight"},"32")])])])])])])])])])])])])],-1),v=s('<ul><li>用户空间内只能执行受限的指令（Ring3），而且不能直接调用系统资源，必须通过内核提供的接口访问</li><li>内核空间可以执行特权命令（Ring0），调用一切系统资源</li></ul><p>当进程运行在用户空间时称为用户态，运行在内核空间时称为内核态。</p><p>Linux 系统为了提高 IO 效率，会在用户空间和内核空间都加入缓冲区：</p><ul><li>写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备</li><li>读数据是，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</li></ul><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="hint-container tip"><p class="hint-container-title">5种IO模型</p><ol><li>阻塞 IO（Blocking IO）</li><li>非阻塞 IO（Nonblocking IO）</li><li>IO 多路复用（IO Multiplexing）</li><li>信号驱动 IO（Signal Driven IO）</li><li>异步 IO（Asynchronous IO）</li></ol></div><h2 id="阻塞io" tabindex="-1"><a class="header-anchor" href="#阻塞io"><span>阻塞IO</span></a></h2><p>顾名思义，阻塞 IO 就是在<strong>等待数据</strong>和<strong>拷贝数据到用户空间</strong>两个阶段过程中都必须阻塞等待。</p><figure><img src="'+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li>用户线程发出 IO 请求</li><li>内核会去查看数据是否准备就绪，如果没有准备就绪那么就会一直等待，而用户线程就会处于阻塞状态，用户线程处于阻塞状态</li><li>当数据准备就绪以后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除阻塞状态</li></ol><p>可以看到，阻塞IO模型中，用户进程在两个阶段都是阻塞状态。</p><h2 id="非阻塞io" tabindex="-1"><a class="header-anchor" href="#非阻塞io"><span>非阻塞IO</span></a></h2><p>非阻塞 IO 的 recvfrom 操作会立即返回结果，而不是阻塞用户进程。</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li>等待数据阶段，如果数据没有就绪，则立刻返回 EWOULDBLOCK。这个过程用户进程是非阻塞的，但是用户进程会一直发起请求，忙轮训，直到内核处理才开始停止轮训。</li><li>数据就绪以后，再将数据从内核中拷贝至用户空间。这个阶段用户进程是阻塞的。</li></ol><p>可以看到，非阻塞 IO 模型中，用户进程在第一个阶段是非阻塞的，在第二个阶段是阻塞的。虽然是非阻塞的，但是性能并没有得到提高，而且忙等机制会导致 CPU 空转，CPU 使用率暴增。</p><h2 id="io多路复用" tabindex="-1"><a class="header-anchor" href="#io多路复用"><span>IO多路复用</span></a></h2><p>无论是阻塞 IO 还是非阻塞 IO，用户应用在一阶段都是需要调用 recvfrom 来获取数据，差别在于无数据时的处理方式：</p><ul><li>如果调用 recvfrom 时，恰好没有数据，阻塞 IO 会使进程阻塞，非阻塞 IO 会使CPU空转，均无法发挥 CPU 的作用。</li><li>如果调用 recvfrom 时，恰好有数据，则用户进程可以直接进入第二阶段，读取并处理数据</li></ul><p>比如服务端处理客户端Socket 请求时，在单线程情况下，只能依次处理每一个 Socket，如果正在处理 socket 恰好未就绪（数据不可读或者不可写），线程就会被阻塞，所有其它客户端 socket 都必须等待，性能自然很差。</p><p>文件描述符（File Descriptor）：简称FD，是一个从 0 开始递增的无符号整数，用来关联 Linux 中的一个文件。在 Linux 中一切皆文件，例如常规文件、视频、硬件设备等，当然也包括网络套接字（Socket）</p><p>IO多路复用：是利用单个线程来同时监听多个 FD ，并在某个 FD 可读、可写时得到通知，从而避免无效的等待，充分利用 CPU 资源。</p><figure><img src="'+r+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>实现 IO 多路复用的技术有三种方式：</p><ul><li>select</li><li>poll</li><li>epoll</li></ul><p><strong>差异：</strong></p><ul><li>select 和 poll 只会通知用户进程有FD就绪，但是不确定是那个 FD，需要用户进程逐个遍历 FD 来确认</li><li>epoll 会通知用户进程 FD 就绪的同时，把已就绪的 FD 写入用户空间，直接能定位到就绪的 FD</li></ul><h3 id="select" tabindex="-1"><a class="header-anchor" href="#select"><span>SELECT</span></a></h3><p>select 是 Linux 中最早的 I/O 多路复用的实现方案：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// 定义类型别名 __fd_mask，本质是 long int</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> long</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> __fd_mask;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">/* fd_set 记录要监听的fd集合，及其对应状态 */</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    // fds_bits是long类型数组，长度为 1024/32 = 32</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    // 共1024个bit位，每个bit位代表一个fd，0代表未就绪，1代表就绪</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    __fd_mask </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">fds_bits</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[__FD_SETSIZE </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">/</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> __NFDBITS];</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} fd_set;</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// select函数，用于监听多个fd的集合</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> nfds</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// 要监视的fd_set的最大fd + 1</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    fd_set </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">readfds</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// 要监听读事件的fd集合</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    fd_set </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">writefds</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// 要监听写事件的fd集合</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    fd_set </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">exceptfds</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  // 要监听异常事件的fd集合</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    // 超时时间，nulT-永不超时;0-不阻塞等待;大于0-固定等待时间</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    struct</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> timeval </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">timeout</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+c+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>具体流程如下：</p><ol><li>用户空间中创建 fd_set rfds</li><li>假如要监听 fd = 1，2，5</li><li>用户空间中执行 selec(5 + 1, rfds, null, null, 3)</li><li>将用户空间中创建的 fd_set rfds 数组拷贝到内核空间中</li><li>内核空间中遍历拷贝后的 fd_set rfds 数组</li><li>如果没有就绪，则将该位置的 fd 设置为0。</li></ol><p><strong>select模式存在的问题：</strong></p><ul><li>需要将整个fd_set从用户空间拷贝到内核空间，select结束还要再次拷贝回用户空间</li><li>select无法得知具体是哪个fd就绪，需要遍历fd_set</li><li>fd_set监听的fd数量不能超过1024、</li></ul><h3 id="poll" tabindex="-1"><a class="header-anchor" href="#poll"><span>POLL</span></a></h3><p>poll 模式对 select 模式做了简单改进，但是性能提升并不明显，部分关键代码如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// pollfd 中的事件类型</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> POLLIN</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">      //可读事件</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> POLLOUT</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">     //可写事件</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> POLLERR</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">     //错误事件</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> POLLNVAL</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    //fd未打开</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// pollfd结构</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> pollfd{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> fd;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">             // 要监听的 fd</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    *short</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> events;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  // 要监听的事件类型:读、写、异常</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    short</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> revents;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  // 实际发生的事件类型</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// poll函数</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> poll</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    struct</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> pollfd </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">xfds</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> // pollfd数组，可以自定义大小</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">    nfds_t</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> nfds</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // 数组元素个数</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> timeout</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">         // 超时时间</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>IO 流程：</strong></p><ol><li>创建 pollfd 数组，向其中添加关注的fd 信息，数组大小自定义</li><li>调用 poll 函数，将 pollfd 数组拷贝到内核空间，转链表存储，无上限</li><li>内核遍历 fd ，判断是否就绪</li><li>数据就绪或超时后，拷贝 pollfd 数组到用户空间，返回就绪 fd 数量 n</li><li>用户进程判断 n 是否大于 0</li><li>大于 0 则遍历 pollfd 数组，找到就绪的 fd</li></ol><p><strong>与 SELECT 比较：</strong></p><ul><li>select 模式中的 fd_set 大小固定值为 1024 ，而 pollfd 在内核中采用链表，理论上是无限的</li><li>监听的 FD 越多，每次遍历消耗的时间也越久，性能反而会下降</li></ul><h3 id="epoll" tabindex="-1"><a class="header-anchor" href="#epoll"><span>EPOLL</span></a></h3><p>epoll 模式是对 select 和 poll 模式的改进， 提供了三个函数：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> eventpoll{</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    //...</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> rb_root rbr;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> // 一颗红黑树，记录要监听的fd</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> list_head rdlist;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  // 一个链表，记录就绪的 FD</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    //...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// 1.会在内核创建eventpolL结构体，返回对应的句柄epfd</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> epoll </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">create</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> size</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// 2.将一个FD添加到epol的红黑树中，并设置ep_poli_calLback</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// calTback触发时，就把对应的FD加入到rdlist这个就绪列表中</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> epoll </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">_ctl</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> epfd</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">   // epoll实例的句柄</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> op</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">     // 要执行的操作，包括：ADD、MOD、DEL</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> fd</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">     // 要监听的 FD</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    struct</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> epoll_event </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">event</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> // 要监听的事件类型: 读、写、异常等</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// 3.检查rdlist列表是否为空，不为空则返回就绪的FD的数量</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> epoll </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">wait</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> epfd</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">       // eventpoll 实例的句柄</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    struct</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> epoll_event </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">events</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> // 空event 数组，用于接收就绪的 FD</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> maxevents</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  // events 数组的最大长度</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> timeout</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> // 超时时间，-1永不超时;0不阻塞;大于0为阻塞时间</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="事件通知机制" tabindex="-1"><a class="header-anchor" href="#事件通知机制"><span>事件通知机制</span></a></h3><p>当 FD 有数据可读时，我们调用 epoll_wait 就可以得到通知，但是时间通知的模式有两种：</p><ul><li>LevelTriggered：简称 LT。当 FD 有数据可读时，会重复通知多次，直至数据处理完成。是 epoll 的默认模式。</li><li>EdgeTriggered：简称 ET。当 FD 有数据可读时，只会通知一次，不管数据是否被处理完成</li></ul><div class="hint-container info"><p class="hint-container-title">举个例子</p><ol><li>假设一个客户端 Socket 对应的 FD 已经注册到了 epoll 实例中</li><li>客户端 Socket 发送了 2kb 的数据</li><li>服务端调用 epoll_wait ，得到通知说 FD 就绪</li><li>服务端从 FD 读取了 1kb 的数据</li><li>回到步骤三（再次调用 epoll_wait ，形成循环）</li></ol></div><p>结论</p><ul><li>ET 模式避免了 LT 模式可能出现的惊群现象</li><li>ET 模式最好结合非阻塞 IO 读取 FD 数据，相比 LT 会复杂一些</li></ul><h3 id="web服务流程" tabindex="-1"><a class="header-anchor" href="#web服务流程"><span>WEB服务流程</span></a></h3><p>基于 epoll 模式的 web 服务的基本流程图：</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p><strong>select 模式的存在的三个问题：</strong></p><ul><li>能监听的 FD 最大不超过 1024 个</li><li>每次 select 都需要把所有要监听的 FD 都拷贝到内核空间</li><li>每次都要遍历所有 FD 来判断就绪状态</li></ul><p><strong>poll 模式的问题：</strong></p><ul><li>poll 利用链表解决了 select 中监听 FD 上限的问题，但是依然要遍历所有的 FD ，如果监听较多，性能会下降</li></ul><p><strong>epoll 模式中如何解决这些问题:</strong></p><ul><li>基于 epoll 实例中的红黑树保存要监听的 FD ，理论上无上限，而且增删改查效率都非常高，性能不会随监听的 FD 数量增多而产生显著的下降</li><li>每个 FD 只需要执行一次 epoll_ctl 添加到红黑树，以后每次 epoll_wait 无需传递任何参数，无需重复拷贝 FD 到内核空间</li><li>内核会将就绪的 FD 直接拷贝到用户空间的指定位置，用户进程无需遍历所有 FD 就能知道就绪的 FD 是谁</li></ul><h2 id="信号驱动io" tabindex="-1"><a class="header-anchor" href="#信号驱动io"><span>信号驱动IO</span></a></h2><p>信号驱动 IO 是与内核建立 SIGIO 的信号关联并设置回调，当内核有 FD 就绪时，会发出 SIGIO 信号通知用户，期间用户应用可以执行其他业务，无需阻塞等待。</p><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当有大量 IO 操作时，信号较多，SIGIO 处理函数不能及时处理可能导致信号队列溢出。</p><p>而且内核空间与用户空间的频繁信号交互性能也较低。</p><h2 id="异步io" tabindex="-1"><a class="header-anchor" href="#异步io"><span>异步IO</span></a></h2><p>异步 IO 的整个过程都是非阻塞的，用户进程调用完异步 API 后就可以去做其他事情，内核等待数据就绪并拷贝到用户空间后才会递交信号，通知用户进程。</p><figure><img src="'+A+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在异步 IO 模型中，用户进程在两个阶段都是非阻塞的状态。</p><p>异步 IO 模型虽然很简单，但是在高并发的访问下，内核中会处理大量请求，容易导致内核崩溃。</p><h2 id="同步和异步" tabindex="-1"><a class="header-anchor" href="#同步和异步"><span>同步和异步</span></a></h2><p>IO 操作是同步还是异步，关键看数据在内核空间与用户空间的拷贝过程（数据读写的IO操作），也就是阶段二是同步还是异步：</p><figure><img src="'+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',75),F=[u,m,v];function b(B,D){return t(),n("div",null,F)}const O=a(f,[["render",b],["__file","redis-principle-IO.html.vue"]]),x=JSON.parse('{"path":"/database/redis/principle/redis-principle-IO.html","title":"Redis原理 - IO详解","lang":"zh-CN","frontmatter":{"order":28,"description":"Redis原理 - IO详解 用户空间与内核空间 任何Linux 系统的发行版，其系统内核都是 Linux 。我们的应用都需要通过 Linux 内核与硬件交互。 为了避免用户应用导致冲突甚至内核崩溃，用户应用与内核是分离的： 内存的寻址空间划分为两部分：内核空间、用户空间 32 位的操作系统，寻址地址就为 0 ~ 232 用户空间内只能执行受限的指令（...","head":[["meta",{"property":"og:url","content":"https://www.codermast.com/database/redis/principle/redis-principle-IO.html"}],["meta",{"property":"og:site_name","content":"友人的编程指南"}],["meta",{"property":"og:title","content":"Redis原理 - IO详解"}],["meta",{"property":"og:description","content":"Redis原理 - IO详解 用户空间与内核空间 任何Linux 系统的发行版，其系统内核都是 Linux 。我们的应用都需要通过 Linux 内核与硬件交互。 为了避免用户应用导致冲突甚至内核崩溃，用户应用与内核是分离的： 内存的寻址空间划分为两部分：内核空间、用户空间 32 位的操作系统，寻址地址就为 0 ~ 232 用户空间内只能执行受限的指令（..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-31T07:38:39.000Z"}],["meta",{"property":"article:author","content":"友人"}],["meta",{"property":"article:modified_time","content":"2024-05-31T07:38:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis原理 - IO详解\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-31T07:38:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"友人\\",\\"url\\":\\"https://www.codermast.com\\",\\"email\\":\\"codermast@163.com\\"}]}"]]},"headers":[{"level":2,"title":"用户空间与内核空间","slug":"用户空间与内核空间","link":"#用户空间与内核空间","children":[]},{"level":2,"title":"阻塞IO","slug":"阻塞io","link":"#阻塞io","children":[]},{"level":2,"title":"非阻塞IO","slug":"非阻塞io","link":"#非阻塞io","children":[]},{"level":2,"title":"IO多路复用","slug":"io多路复用","link":"#io多路复用","children":[{"level":3,"title":"SELECT","slug":"select","link":"#select","children":[]},{"level":3,"title":"POLL","slug":"poll","link":"#poll","children":[]},{"level":3,"title":"EPOLL","slug":"epoll","link":"#epoll","children":[]},{"level":3,"title":"事件通知机制","slug":"事件通知机制","link":"#事件通知机制","children":[]},{"level":3,"title":"WEB服务流程","slug":"web服务流程","link":"#web服务流程","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]},{"level":2,"title":"信号驱动IO","slug":"信号驱动io","link":"#信号驱动io","children":[]},{"level":2,"title":"异步IO","slug":"异步io","link":"#异步io","children":[]},{"level":2,"title":"同步和异步","slug":"同步和异步","link":"#同步和异步","children":[]}],"git":{"createdTime":1687241391000,"updatedTime":1717141119000,"contributors":[{"name":"codermast","email":"codermast@qq.com","commits":1}]},"readingTime":{"minutes":9.9,"words":2971},"filePathRelative":"database/redis/principle/redis-principle-IO.md","localizedDate":"2023年6月20日","autoDesc":true,"excerpt":"\\n<h2>用户空间与内核空间</h2>\\n<p>任何Linux 系统的发行版，其系统内核都是 Linux 。我们的应用都需要通过 Linux 内核与硬件交互。</p>\\n<figure><figcaption></figcaption></figure>\\n<p>为了避免用户应用导致冲突甚至内核崩溃，用户应用与内核是分离的：</p>\\n<ul>\\n<li>内存的寻址空间划分为两部分：内核空间、用户空间</li>\\n</ul>\\n<blockquote>\\n<p>32 位的操作系统，寻址地址就为 0 ~ <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding=\\"application/x-tex\\">2 ^ {32}</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.8141em;\\"></span><span class=\\"mord\\"><span class=\\"mord\\">2</span><span class=\\"msupsub\\"><span class=\\"vlist-t\\"><span class=\\"vlist-r\\"><span class=\\"vlist\\" style=\\"height:0.8141em;\\"><span style=\\"top:-3.063em;margin-right:0.05em;\\"><span class=\\"pstrut\\" style=\\"height:2.7em;\\"></span><span class=\\"sizing reset-size6 size3 mtight\\"><span class=\\"mord mtight\\"><span class=\\"mord mtight\\">32</span></span></span></span></span></span></span></span></span></span></span></span></p>\\n</blockquote>"}');export{O as comp,x as data};
