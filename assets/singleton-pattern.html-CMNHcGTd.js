import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,a as e}from"./app-CzDKfAo4.js";const t={},p=e(`<h1 id="单例模式" tabindex="-1"><a class="header-anchor" href="#单例模式"><span>单例模式</span></a></h1><p>单例模式是最常用的设计模式之一，他可以保证在整个应用中，某个类只存在一个实例化对象，即全局使用到该类的只有一个对象，这种模式在需要限制某些类的实例数量时非常有用，通常全局只需要一个该对象即可，如一些配置文件映射对象、数据库连接对象等。</p><div class="hint-container tip"><p class="hint-container-title">饿汉模式 和 懒汉模式</p><p>单例模式根据其实现方式不同，又可以分成两种类型：饿汉模式 和 懒汉模式。</p><ul><li><p>饿汉模式：可以理解为餐馆老板认为每个顾客来到餐馆时都是快要饿死的状态，一旦请求食物，则必须立刻提供给他，必须尽快让他吃到东西，为了达到这样的效果，就必须提前把食物准备好，只等顾客来吃即可。</p></li><li><p>懒汉模式：可以理解为餐馆老板是一个非常懒的人，没有客人的时候，他什么也不会准备，只有当顾客点餐以后，老板才会开始工作。</p></li></ul></div><h2 id="设计思想" tabindex="-1"><a class="header-anchor" href="#设计思想"><span>设计思想</span></a></h2><ol><li>日志记录</li></ol><p>在应用程序中，通常会有多个模块需要记录日志，为了避免创建多个日志记录器实例，使用单例模式就可以确保只有一个日志记录器实例，从而避免重复记录日志并提高应用程序的性能。</p><ol start="2"><li>数据库连接</li></ol><p>在应用程序中，需要频繁的和数据库进行交互，使用单例模式可以确保只有一个数据库连接实例，从而减少数据库连接的数量，提高程序的性能，减少资源的消耗。</p><ol start="3"><li>配置文件</li></ol><p>在应用程序中，通常会有一些全局的配置参数，如数据连接信息、项目配置信息、缓存大小等一些参数，使用单例模式可以确保只有一个配置实例，保证了参数的唯一性，从而方便管理和修改配置参数。</p><h2 id="实现案例" tabindex="-1"><a class="header-anchor" href="#实现案例"><span>实现案例</span></a></h2><h3 id="饿汉模式" tabindex="-1"><a class="header-anchor" href="#饿汉模式"><span>饿汉模式</span></a></h3><p>这种模式下，即使当前没有人来请求资源，在类加载的时候就会提前将所需要的资源准备好，只等来拿。</p><p>因为是在类加载的阶段初始化的，且类加载在程序的执行过程中仅出现一次，故其是线程安全的。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">SingletonHungry</span> <span class="token punctuation">{</span>
    <span class="token comment">// static 修饰的，在类加载时就会被初始化</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">SingletonHungry</span> singletonHungry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonHungry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 将构造器设为私有的，禁止从外部创建实例</span>
    <span class="token keyword">private</span> <span class="token class-name">SingletonHungry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>

    <span class="token comment">// 提供获取单例对象的方法</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SingletonHungry</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> singletonHungry<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="懒汉模式" tabindex="-1"><a class="header-anchor" href="#懒汉模式"><span>懒汉模式</span></a></h3><p>这种模式下，只有当有人来获取资源的时候，才会开始准备资源。因为是需要进行手动初始化，在并发环境下就有可能出现构建了多个实例对象的情况，需要我们手动去处理。</p><ul><li>懒汉模式：不考虑并发</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">SingletonLazy</span> <span class="token punctuation">{</span>
    <span class="token comment">// 默认不初始化</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">SingletonLazy</span> singletonLazy<span class="token punctuation">;</span>

    <span class="token comment">// 将构造器设为私有的，禁止从外部创建实例</span>
    <span class="token keyword">private</span> <span class="token class-name">SingletonLazy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>

    <span class="token comment">// 提供获取单例对象的方法</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SingletonLazy</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonLazy <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            singletonLazy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonLazy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> singletonLazy<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>懒汉模式：考虑并发</li></ul><p>使用双重检查锁它可以在保证线程安全的同时实现延迟加载</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">SingletonLazy</span> <span class="token punctuation">{</span>
    <span class="token comment">// 默认不初始化</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">SingletonLazy</span> singletonLazy<span class="token punctuation">;</span>

    <span class="token comment">// 将构造器设为私有的，禁止从外部创建实例</span>
    <span class="token keyword">private</span> <span class="token class-name">SingletonLazy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>

    <span class="token comment">// 提供获取单例对象的方法</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SingletonLazy</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonLazy <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span> <span class="token class-name">SingletonLazy</span><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonLazy <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    singletonLazy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonLazy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> singletonLazy<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="枚举方式" tabindex="-1"><a class="header-anchor" href="#枚举方式"><span>枚举方式</span></a></h3><div class="hint-container caution"><p class="hint-container-title">警告</p><p>前面的两种方式中，看似是实现了单例模式，但是 Java 中一些机制可以破坏单例模式，会导致单例对象不唯一，例如反射机制、克隆机制、序列化和反序列化等。那这该如何解决呢？答案是使用 Enum 类来实现。</p></div><p>使用枚举实现单例模式的好处是，可以避免反射和序列化攻击。因为枚举类型的构造函数是私有的，所以无法使用反射来创建实例；而且枚举类型的实例在序列化和反序列化时会自动处理好，所以也无法通过序列化和反序列化来破坏单例。</p><ul><li>定义枚举类</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">SingletonEnum</span> <span class="token punctuation">{</span>
    <span class="token constant">SINGLETONENUM</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// TODO：这里可以写一些单例对象的相关行为和操作</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>使用枚举类</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonEnumTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SingletonEnum</span> singletonEnum <span class="token operator">=</span> <span class="token class-name">SingletonEnum</span><span class="token punctuation">.</span><span class="token constant">SINGLETON_ENUM</span><span class="token punctuation">;</span>
        <span class="token class-name">SingletonEnum</span> singletonEnum2 <span class="token operator">=</span> <span class="token class-name">SingletonEnum</span><span class="token punctuation">.</span><span class="token constant">SINGLETON_ENUM</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>singletonEnum  <span class="token operator">==</span> singletonEnum2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出的结果为 true ，说明这两个是同一个对象。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><ul><li><p>如果对线程安全和性能要求较高，可以考虑使用饿汉式或双重检查锁方式实现单例模式。这两种方式都能保证线程安全，而且在大多数情况下性能也比较好。</p></li><li><p>如果对线程安全要求不是很高，或者希望在第一次访问时才创建单例对象，可以考虑使用懒汉式或者静态内部类方式。这两种方式都是延迟加载的，只有在需要时才会创建单例对象。懒汉式不是线程安全的，需要通过加锁等方式来保证线程安全；而静态内部类方式则是天生线程安全的，不需要额外的处理。</p></li><li><p>希望实现简单、代码少，且不需要考虑线程安全和延迟加载的问题，可以考虑使用枚举方式。这种方式不仅代码简单，而且天生线程安全、单例对象创建和调用都很方便。</p></li></ul><p>总之，选择哪种实现方式需要根据具体需求来决定，需要综合考虑线程安全、性能、代码复杂度、延迟加载等因素。</p>`,33),l=[p];function i(c,o){return s(),a("div",null,l)}const r=n(t,[["render",i],["__file","singleton-pattern.html.vue"]]),k=JSON.parse('{"path":"/dev-idea/design-patterns/create-patterns/singleton-pattern.html","title":"单例模式","lang":"zh-CN","frontmatter":{"order":1,"description":"单例模式 单例模式是最常用的设计模式之一，他可以保证在整个应用中，某个类只存在一个实例化对象，即全局使用到该类的只有一个对象，这种模式在需要限制某些类的实例数量时非常有用，通常全局只需要一个该对象即可，如一些配置文件映射对象、数据库连接对象等。 饿汉模式 和 懒汉模式 单例模式根据其实现方式不同，又可以分成两种类型：饿汉模式 和 懒汉模式。 饿汉模式：...","head":[["meta",{"property":"og:url","content":"https://www.codermast.com/dev-idea/design-patterns/create-patterns/singleton-pattern.html"}],["meta",{"property":"og:site_name","content":"CoderMast编程桅杆"}],["meta",{"property":"og:title","content":"单例模式"}],["meta",{"property":"og:description","content":"单例模式 单例模式是最常用的设计模式之一，他可以保证在整个应用中，某个类只存在一个实例化对象，即全局使用到该类的只有一个对象，这种模式在需要限制某些类的实例数量时非常有用，通常全局只需要一个该对象即可，如一些配置文件映射对象、数据库连接对象等。 饿汉模式 和 懒汉模式 单例模式根据其实现方式不同，又可以分成两种类型：饿汉模式 和 懒汉模式。 饿汉模式：..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-29T13:18:57.000Z"}],["meta",{"property":"article:author","content":"友人"}],["meta",{"property":"article:modified_time","content":"2024-04-29T13:18:57.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"单例模式\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-29T13:18:57.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"友人\\",\\"url\\":\\"https://www.codermast.com\\",\\"email\\":\\"codermast@163.com\\"}]}"]]},"headers":[{"level":2,"title":"设计思想","slug":"设计思想","link":"#设计思想","children":[]},{"level":2,"title":"实现案例","slug":"实现案例","link":"#实现案例","children":[{"level":3,"title":"饿汉模式","slug":"饿汉模式","link":"#饿汉模式","children":[]},{"level":3,"title":"懒汉模式","slug":"懒汉模式","link":"#懒汉模式","children":[]},{"level":3,"title":"枚举方式","slug":"枚举方式","link":"#枚举方式","children":[]}]},{"level":2,"title":"小结","slug":"小结","link":"#小结","children":[]}],"git":{"createdTime":1714012832000,"updatedTime":1714396737000,"contributors":[{"name":"codermast","email":"codermast@qq.com","commits":2}]},"readingTime":{"minutes":5.01,"words":1502},"filePathRelative":"dev-idea/design-patterns/create-patterns/singleton-pattern.md","localizedDate":"2024年4月25日","autoDesc":true,"excerpt":"\\n<p>单例模式是最常用的设计模式之一，他可以保证在整个应用中，某个类只存在一个实例化对象，即全局使用到该类的只有一个对象，这种模式在需要限制某些类的实例数量时非常有用，通常全局只需要一个该对象即可，如一些配置文件映射对象、数据库连接对象等。</p>\\n<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">饿汉模式 和 懒汉模式</p>\\n<p>单例模式根据其实现方式不同，又可以分成两种类型：饿汉模式 和 懒汉模式。</p>\\n<ul>\\n<li>\\n<p>饿汉模式：可以理解为餐馆老板认为每个顾客来到餐馆时都是快要饿死的状态，一旦请求食物，则必须立刻提供给他，必须尽快让他吃到东西，为了达到这样的效果，就必须提前把食物准备好，只等顾客来吃即可。</p>\\n</li>\\n<li>\\n<p>懒汉模式：可以理解为餐馆老板是一个非常懒的人，没有客人的时候，他什么也不会准备，只有当顾客点餐以后，老板才会开始工作。</p>\\n</li>\\n</ul>\\n</div>"}');export{r as comp,k as data};
