import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as a,a as e}from"./app-BLUmwQj7.js";const l="/assets/2023-06-22-17-58-07-BKe9VcuK.png",t="/assets/2023-06-22-18-41-05-DnBXic6f.png",n={},k=e('<h1 id="redis原理-内存策略" tabindex="-1"><a class="header-anchor" href="#redis原理-内存策略"><span>Redis原理 - 内存策略</span></a></h1><p>Redis 本身是一个典型的 key-value 内存存储数据库，因此所有的 key、value 都保存在之前学习过的 Dict 结构中。不过在其 database 结构体中，有两个 Dict ：一个用来记录 key-value；另外一个用来记录 key-TTL</p><figure><img src="'+l+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> redisDb {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    dict </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">dict;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">     // 存放所有 key 和 value 的地方</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    dict </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">expires;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  // 存放每一个 key 及其对应的 TTL 存活时间，只包含设置了 TTL 的 key</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    dict </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">blocking_keys;   </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    dict </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">ready_keys;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    dict </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">watched_keys;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">         // Database ID ：0 ~ 15</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    long</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> long</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> avg_ttl;  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    unsigned</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> long</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> expires_cursor;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">   // expire 检查时在 dict 中抽样的索引位置</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    list </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">defrag_later;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> // 等待碎片整理的 key 列表</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} redisDb;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Redis 是如何知道一个 key 是否过期呢？</strong></p><p>答：利用两个 Dict 分别记录 key-value 和 key-ttl</p><p><strong>是不是 TTL 到期就立刻删除呢？</strong></p><p>答：并不是到期立刻删除，而是采用 <em><strong>惰性删除</strong></em> 和 <em><strong>周期删除</strong></em>。</p><h2 id="删除策略" tabindex="-1"><a class="header-anchor" href="#删除策略"><span>删除策略</span></a></h2><ul><li><p>定时删除：TTL 到期后，立刻删除对应的 key</p></li><li><p>惰性删除：并不是在 TTL 到期后就立刻删除，而是在访问一个 key 的时候，检查该 key 的存活时间，如果已经过期，才执行删除。</p></li><li><p>周期删除：是通过一个定时任务，周期性的抽样部分过期的 key，然后执行删除。执行周期有两种：</p><ul><li>Redis 会设置一个定时任务 serverCron()，按照 server.hz 的频率来执行过期 key 清理，模式为 SLOW，默认为 10</li><li>Redis 的每个事情循环前会调用beforeSleep()函数，执行过期key清理，模式为FAST</li></ul></li></ul><p><strong>SLOW模式规则:</strong></p><ol><li><p>执行频率受server.hz影响，默认为10，即每秒执行10次，每个执行周期100ms。</p></li><li><p>执行清理耗时不超过一次执行周期的25%.</p></li><li><p>逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期</p></li><li><p>如果没达到时间上限 (25ms)并且过期key比例大于10%，再进行一次抽样，否则结束</p></li></ol><p><strong>FAST模式规则 (过期key比例小于10%不执行)</strong></p><ol><li>执行频率受beforeSleep()调用频率影响，但两次FAST模式间隔不低于2ms</li><li>执行清理耗时不超过1ms</li><li>逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期</li><li>如果没达到时间上限 (1ms)并且过期key比例大于10%，再进行一次抽样，否则结束</li></ol><h2 id="淘汰策略" tabindex="-1"><a class="header-anchor" href="#淘汰策略"><span>淘汰策略</span></a></h2><p>内存淘汰就是当 Redis 内存使用达到设置的阈值时，Redis 主动挑选部分 key 删除以释放更多的内存的流程。Redis 会在处理客户端命令的方法 processCommand() 中尝试做内存淘汰。</p><p>Redis 一共支持 8 种淘汰策略</p><ul><li><p>noeviction：当内存使用超过配置的时候会返回错误，不会驱逐任何键。</p></li><li><p>allkeys-lru：加入键的时候，如果过限，首先通过LRU算法驱逐最久没有使用的键。</p></li><li><p>volatile-lru：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键。</p></li><li><p>allkeys-random：加入键的时候如果过限，从所有key随机删除。</p></li><li><p>volatile-random：加入键的时候如果过限，从过期键的集合中随机驱逐。</p></li><li><p>volatile-ttl：从配置了过期时间的键中驱逐马上就要过期的键。</p></li><li><p>volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键。</p></li><li><p>allkeys-lfu：从所有键中驱逐使用频率最少的键。</p></li></ul><p>LRU(Least Recently Used)：最少最近使用，用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</p><p>LFU(Least Frequently Used)：最少频率使用，会统计每个 key 的访问频率，值越小淘汰优先级越高。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> redisObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    unsigned</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> type:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">//对象类型</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    unsigned</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> encoding:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// 编码方式</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    unsigned</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> lru:LRU_BITS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    //LRU: 以秒为单位记录最近一次访问时间，长度24bit</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    //LFU: 高16位以分钟为单位记录最近一次访问时间，低8位记录逻辑访问次数</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> refcount</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">   // 引用计数，计数为0则可以回收</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    void</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">ptr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">      // 数据指针，指向真实数据</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) robj;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>LRU 的访问次数之所以叫做逻辑访问次数，是因为并不是每次 key 被访问都计数，而是通过运算：</p><ol><li>生成 0 ~ 1 之间的随机数 R</li><li>计算 1 / (旧次数 * lfu_log_factor + 1)，记录为 R，lfu_log_factor 默认为 10</li><li>如果 R &lt; P，则计数器 + 1，且最大不超过 255</li><li>访问次数会随时间缩减，距离上一次访问时间每隔 lfu_decay_time 分钟（默认 1），计数器 -1</li></ol><figure><img src="`+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',24),h=[k];function p(d,r){return a(),s("div",null,h)}const A=i(n,[["render",p],["__file","redis-principle-memery-strategy.html.vue"]]),g=JSON.parse('{"path":"/database/redis/principle/redis-principle-memery-strategy.html","title":"Redis原理 - 内存策略","lang":"zh-CN","frontmatter":{"order":31,"description":"Redis原理 - 内存策略 Redis 本身是一个典型的 key-value 内存存储数据库，因此所有的 key、value 都保存在之前学习过的 Dict 结构中。不过在其 database 结构体中，有两个 Dict ：一个用来记录 key-value；另外一个用来记录 key-TTL Redis 是如何知道一个 key 是否过期呢？ 答：利用两...","head":[["meta",{"property":"og:url","content":"https://www.codermast.com/database/redis/principle/redis-principle-memery-strategy.html"}],["meta",{"property":"og:site_name","content":"友人的编程指南"}],["meta",{"property":"og:title","content":"Redis原理 - 内存策略"}],["meta",{"property":"og:description","content":"Redis原理 - 内存策略 Redis 本身是一个典型的 key-value 内存存储数据库，因此所有的 key、value 都保存在之前学习过的 Dict 结构中。不过在其 database 结构体中，有两个 Dict ：一个用来记录 key-value；另外一个用来记录 key-TTL Redis 是如何知道一个 key 是否过期呢？ 答：利用两..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-31T07:38:39.000Z"}],["meta",{"property":"article:author","content":"友人"}],["meta",{"property":"article:modified_time","content":"2024-05-31T07:38:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis原理 - 内存策略\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-31T07:38:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"友人\\",\\"url\\":\\"https://www.codermast.com\\",\\"email\\":\\"codermast@163.com\\"}]}"]]},"headers":[{"level":2,"title":"删除策略","slug":"删除策略","link":"#删除策略","children":[]},{"level":2,"title":"淘汰策略","slug":"淘汰策略","link":"#淘汰策略","children":[]}],"git":{"createdTime":1687430561000,"updatedTime":1717141119000,"contributors":[{"name":"codermast","email":"codermast@qq.com","commits":1}]},"readingTime":{"minutes":4.01,"words":1202},"filePathRelative":"database/redis/principle/redis-principle-memery-strategy.md","localizedDate":"2023年6月22日","autoDesc":true,"excerpt":"\\n<p>Redis 本身是一个典型的 key-value 内存存储数据库，因此所有的 key、value 都保存在之前学习过的 Dict 结构中。不过在其 database 结构体中，有两个 Dict ：一个用来记录 key-value；另外一个用来记录 key-TTL</p>\\n<figure><figcaption></figcaption></figure>\\n<div class=\\"language-c line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"c\\" data-title=\\"c\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">typedef</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\"> struct</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> redisDb {</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">    dict </span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">*</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">dict;</span><span style=\\"--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic\\">     // 存放所有 key 和 value 的地方</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">    dict </span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">*</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">expires;</span><span style=\\"--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic\\">  // 存放每一个 key 及其对应的 TTL 存活时间，只包含设置了 TTL 的 key</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">    dict </span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">*</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">blocking_keys;   </span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">    dict </span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">*</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">ready_keys;</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">    dict </span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">*</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">watched_keys;</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">    int</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> id;</span><span style=\\"--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic\\">         // Database ID ：0 ~ 15</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">    long</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\"> long</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> avg_ttl;  </span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">    unsigned</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\"> long</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> expires_cursor;</span><span style=\\"--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic\\">   // expire 检查时在 dict 中抽样的索引位置</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">    list </span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">*</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">defrag_later;</span><span style=\\"--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic\\"> // 等待碎片整理的 key 列表</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">} redisDb;</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>"}');export{A as comp,g as data};
